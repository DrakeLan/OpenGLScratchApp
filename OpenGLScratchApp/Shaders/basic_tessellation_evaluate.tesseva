// tessellation evaluation shader
#version 410 core

layout(std140) uniform globalMatrixBlock
{
    mat4 projection;
    mat4 view;
}block_matrices;



layout (triangles, equal_spacing , ccw) in;

uniform sampler2D heightMap;  // the texture corresponding to our height map
uniform mat4 model;           // the model matrix
uniform float uniformTessHeight;
uniform float debugFlag;

// received from Tessellation Control Shader - all texture coordinates for the patch vertices
in vec2 TextureCoord[];
in vec3 worldNormal[];

// send to Fragment Shader for coloring
out vec3 wnormal;
out vec2 uv;
out float Height;

vec2 Interpolate(vec2 v0, vec2 v1, vec2 v2) 
{   
    return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2; 
}  

vec4 Interpolate3D(vec4 v0, vec4 v1, vec4 v2) 
{   
    return vec4(gl_TessCoord.x) * v0 + vec4(gl_TessCoord.y) * v1 + vec4(gl_TessCoord.z) * v2; 
}  

void main()
{
    // get patch coordinate
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    // ----------------------------------------------------------------------
    // retrieve control point texture coordinates
    vec2 t0 = TextureCoord[0];
    vec2 t1 = TextureCoord[1];
    vec2 t2 = TextureCoord[2];

    vec2 texCoord = Interpolate(t0, t1, t2);

    // lookup texel at patch coordinate for height and scale + shift as desired
    Height = texture(heightMap, texCoord).y * uniformTessHeight;

    // ----------------------------------------------------------------------
    // retrieve control point position coordinates
    vec4 p0 = gl_in[0].gl_Position;
    vec4 p1 = gl_in[1].gl_Position;
    vec4 p2 = gl_in[2].gl_Position;

    vec4 n0 = vec4(worldNormal[0], 0.0);
    vec4 n1 = vec4(worldNormal[1], 0.0);
    vec4 n2 = vec4(worldNormal[2], 0.0);

    vec3 normal = normalize( Interpolate3D(n0, n1, n2)).xyz;

    vec4 p = Interpolate3D(p0, p1, p2);

    // displace point along normal
    p += vec4(normal * Height, 0.0);

    // ----------------------------------------------------------------------
    // output patch point position in clip space
    gl_Position =  block_matrices.projection * block_matrices.view * model * p;
    if(debugFlag > 0.5)
    {
        gl_Position.z -= 0.05;
    }

    uv = texCoord;
    wnormal = normal;
}